<!doctype html>
<html class="no-js" lang="">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <!-- Place favicon.ico in the root directory -->

    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/custom.css"/>
    <script src="js/vendor/modernizr-2.8.3.min.js"></script>
    <script src="js/vendor/jquery-1.11.3.min.js"></script>
    <!-- WebGL related JavaScript files. -->
    <!-- Debugging utilities. Useless really but well... -->
    <script src="debug/webgl-debug.js"></script>
    <script src="debug/webgl-utils.js"></script>

    <!-- Math library -->
    <script src="js/gl-matrix.js"></script>
    <!-- WebGL tool library. Handles canvas loading, program initialization and shader compiling and attachment.-->
    <script src="js/webglTools.js"></script>

    <!--Water shaders.-->
    <script id="shader-vs" type="x-shader/x-vertex">
            const float pi = 3.14159;

            // The matrices.
            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            // The canvas resolution.
            uniform vec3 iResolution;

            // The vertex attributes.
            attribute vec3 aVertexPosition;
            attribute vec4 aColor;
            attribute vec2 aTextureCoord;

            // The light position.
            uniform vec3 uLightPosition;

            // The wave uniforms.
            uniform float iGlobalTime;
            uniform float waveTime;
            uniform float waterHeight;
            uniform float Q; // Wave Steepness.
            uniform float amplitude[4];
            uniform float wavelength[4];
            uniform float speed[4];
            uniform float directionsX[4];
            uniform float directionsY[4];

            // The data to pass to the Fragment shader.
            varying vec3 vFragmentPosition;
            varying vec3 vLightPosition;
            varying vec3 vLightRay;
            varying vec3 vEyeVec;

            varying vec4 vColor;
            varying vec2 vTextureCoord;


            float gerstnerWave(int i, out float x, out float y)
            {
                float frequency = 2.0 * pi / wavelength[i];
                float phase = speed[i] * frequency;
                vec2 di = vec2(directionsX[i],directionsY[i]);
                vec2 dw = vec2(x, y);
                float theta = dot(di,dw);

                float result = theta * frequency + iGlobalTime * phase;
                float Qi = Q;
                if(amplitude[i] != 0.0)
                {
                    float Qi = Q / (frequency * amplitude[i] * float(i+1));
                }

                // Coordinates displacement computation.

                x += Qi * amplitude[i] * di.x * cos(result);
                y += Qi * amplitude[i] * di.y * cos(result);
                float t = amplitude[i] * sin(result);
                return t;
            }

             void gerstnerWavePositionFaster(out float x, out float y,out float z)
            {
                float sumX = x;
                float sumY = y;
                float sumT = z; // Z-axis

                for (int i = 0; i < 4; ++i){
                    sumT += gerstnerWave(i,sumX,sumY);
                }

                x = sumX;
                y = sumY;
                z = sumT;
            }

            float wave(int i, float x, float y)
            {
                float frequency = 2.0 * pi / wavelength[i];
                float phase = speed[i] * frequency;
                vec2 di = vec2(directionsX[i],directionsY[i]);
                vec2 dw = vec2(x, y);
                float theta = dot(di,dw);

                float result = amplitude[i] * sin(theta * frequency + iGlobalTime * phase);
                return result;
            }

            float waveHeight(float x, float y) {
                float height = 0.0;

                for (int i = 0; i < 4; ++i){
                    height += wave(i, x, y);
                }
                return height;
            }

            void main(void) {

                //gl_PointSize = 100.0;

                // Send the texture coordinate to the fragement shader.
                vTextureCoord = aTextureCoord;

                vec4 vertexPos = vec4(aVertexPosition, 1.0);

                // Apply a Gerstner Wave.
                gerstnerWavePositionFaster(vertexPos.x,vertexPos.y,vertexPos.z);

                // Apply a normal sine wave on Z.
                //vertexPos.z = waveHeight(vertexPos.x,vertexPos.y);

                // Get the position in camera-space of the vertex for the fragment shader.
                vFragmentPosition = (uMVMatrix * vertexPos).xyz;


                // The light ray emitted.
                vLightRay = (uPMatrix * uMVMatrix * vertexPos).xyz - uLightPosition.xyz;
				// The eye position.
				// Fake positioning of the eye since the eye is actually at the camera location.
				// We can use this to position the fragment in 3D space.
				// vEyeVec = - vec3(vertexPos.xyz);
				vEyeVec = vec3(vertexPos.xyz);

                // Apply the camera world coordinate transformation and project on the viewport.
                vec4 transformedVertexPos = uPMatrix * uMVMatrix * vertexPos;

                // Not really needed since this was done in the js side.
                //vLightPosition = (uMVMatrix * vec4(uLightPosition, 1.0)).xyz;
                vLightPosition = uLightPosition.xyz;

                // Send the position.
                gl_Position = transformedVertexPos;

                // Change the color to be able to see according to depth.
                vec3 colorComponents = aColor.xyz + transformedVertexPos.z * 0.015;
                vColor = vec4(colorComponents, 1.0);
            }

    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
            #ifdef GL_ES
                precision highp float;
            #endif
            #extension GL_OES_standard_derivatives : enable

            // The matrices.
            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            // Data from the vertex shader.
            varying vec3    vFragmentPosition;

            varying vec4	vColor;
            varying vec2    vTextureCoord;

            varying vec3    vLightPosition;
            varying vec3    vLightRay;
			varying vec3    vEyeVec;

            // The canvas resolution.
            uniform vec3	iResolution;
            // The timer.
            uniform float	iGlobalTime;

            // The light position non discretized.
            uniform vec3    uLightPosition;

            // The camera position. // Probably
            uniform vec3    uCameraPosition;

            uniform sampler2D uColorTexture;

            // Prototypes.
            //void mainImage( out vec4 c,  in vec2 f );

            // "Seascape" by Alexander Alekseev aka TDM - 2014
            // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

            const int NUM_STEPS = 18;
            const float PI		= 3.1415;
            const float EPSILON	= 1e-3;
            float EPSILON_NRM	= 0.1 / iResolution.x;

            // sea
            const int 	ITER_GEOMETRY 	= 1;
            const int 	ITER_FRAGMENT 	= 5;
            const float SEA_HEIGHT 		= 0.4;
            const float SEA_CHOPPY 		= 6.3;
            const float SEA_SPEED 		= 1.8;
            const float SEA_FREQ 		= 0.16;
            const vec3 	SEA_BASE 		= vec3(0.1,0.19,0.22);
            const vec3 	SEA_WATER_COLOR = vec3(0.8,0.9,0.6);
            float 		SEA_TIME 		= iGlobalTime * SEA_SPEED;
            mat2 		octave_m 		= mat2(1.6,1.2,-1.2,1.6);

            // AxisAngle to Matrix
            //http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToMatrix/
            mat3 fromEuler(vec3 ang) {
                vec2 a1 = vec2(sin(ang.x),cos(ang.x));
                vec2 a2 = vec2(sin(ang.y),cos(ang.y));
                vec2 a3 = vec2(sin(ang.z),cos(ang.z));
                mat3 m;
                m[0] = vec3(a1.y * a3.y + a1.x * a2.x * a3.x, a1.y * a2.x * a3.x + a3.y * a1.x, -a2.y * a3.x);
                m[1] = vec3(-a2.y * a1.x, a1.y * a2.y, a2.x);
                m[2] = vec3(a3.y * a1.x * a2.x + a1.y * a3.x, a1.x * a3.x - a1.y * a3.y * a2.x, a2.y * a3.y);
                return m;
            }

            float hash( vec2 p ) {
                float h = dot(p,vec2(127.1,311.7));
                return fract(sin(h)*43758.5453123);
            }

            float noise( in vec2 p ) {
                vec2 i = floor( p );
                vec2 f = fract( p );
                vec2 u = f*f*(3.0-2.0*f);
                return -1.0+2.0*mix(mix( hash( i + vec2(0.0,0.0) ),
                                    hash( i + vec2(1.0,0.0) ), u.x),
                                    mix( hash( i + vec2(0.0,1.0) ),
                                    hash( i + vec2(1.0,1.0) ), u.x), u.y);
            }

            // lighting
            float diffuse(vec3 n,vec3 l,float p) {
                return pow(dot(n,l) * 0.4 + 0.6,p);
            }

            float specular(vec3 n,vec3 l,vec3 e,float s) {
                float nrm = (s + 8.0) / (3.1415 * 8.0);
                return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
            }

            // sky
            vec3 getSkyColor(vec3 e) {
                e.y = max(e.y,0.0);
                vec3 ret;
                ret.x = pow(1.0-e.y,2.0);
                ret.y = 1.0-e.y;
                ret.z = 0.6+(1.0-e.y)*0.4;
                return ret;
            }

            /** Sea Octave
            * TLDR: It is this function that passes a low frequency random terrain through a
            * 2D symmetric wave function that looks like this:
            * http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20
            *
            * The <choppy> parameter affects the wave shape.
            */
            float sea_octave(vec2 uv, float choppy) {
                // Add the smoothed 2D terrain / wave function to the input coordinates
                // which are going to be our X and Z world coordinates.  It may be unclear why we are doing this.
                // This value is about to be passed through a wave function.  So we have a smoothed psuedo random height
                // field being added to our (X, Z) coordinates, and then fed through yet another wav function below.
                uv += noise(uv);

                // Note that you could simply return noise(uv) here and it would take on the characteristics of our
                // noise interpolation function u and would be a reasonable heightmap for terrain.
                // However, that isn't the shape we want in the end for an ocean with waves, so it will be fed through
                // a more wave like function.  Note that although both x and y channels of <uv> have the same value added, there is a
                // symmetry break because <uv>.x and <uv>.y will typically be different values.

                // This is a wave function with pointy peaks and curved troughs:
                // http://www.wolframalpha.com/input/?i=1-abs%28cos%28x%29%29%3B
                vec2 wv = 1.0-abs(sin(uv));

                // This is a wave function with curved peaks and pointy troughs:
                // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29%3B
                vec2 swv = abs(cos(uv));

                // Blending both wave functions gets us a new, cooler wave function (output between 0 and 1):
                // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29+%2B+abs%28cos%28x%29%29+*+%28%281.0-abs%28sin%28x%29%29%29+-+abs%28cos%28x%29%29%29
                wv = mix(wv,swv,wv);

                // Finally, compose both of the wave functions for X and Y channels into a final
                // 1D height value, shaping it a bit along the way.

                // First, there is the composition (multiplication) of
                // the wave functions: wv.x * wv.y.
                // Wolfram will give us a cute 2D height graph for this:
                // http://www.wolframalpha.com/input/?i=%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D
                //
                // Next, we reshape the 2D wave function by exponentiation: (wv.x * wv.y)^0.65.
                // This slightly rounds the base of the wave:
                // http://www.wolframalpha.com/input/?i=%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65
                //
                // One last final transform (with choppy = 4) results in this which resembles a recognizable ocean wave shape in 2D:
                // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4
                //
                // Note that this function is called with a specific frequency multiplier which will stretch out the wave.
                //
                // Here is the graph with the base frequency used by map and map_detailed (0.16):
                // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20
                return pow(1.0-pow(wv.x * wv.y,0.65),choppy);
            }

            /**
            * Compute the distance along Y axis of a point to the surface of the ocean
            * using a low(er) resolution ocean height composition function (less iterations).
            */
            float map(vec3 p) {
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz;
                uv.x *= 0.75;

                /*
                * Compose our wave noise generation ("sea_octave") with different frequencies
                * and offsets to achieve a final height map that looks like an ocean.  Likely lots
                * of black magic / trial and error here to get it to look right.
                * Each sea_octave has this shape:
                * http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20
                */
                float d, h = 0.0;

                for(int i = 0; i < ITER_GEOMETRY; i++) {
                    d = sea_octave((uv+SEA_TIME)*freq,choppy);
                    d += sea_octave((uv-SEA_TIME)*freq,choppy);
                    h += d * amp;
                    uv *= octave_m;
                    freq *= 1.9;
                    amp *= 0.22;
                    choppy = mix(choppy,1.0,0.2);
                }
                return p.y - h;
            }


            float map_detailed(vec3 p) {
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                // Plane.
                vec2 uv = p.xz;
                uv.x *= 0.75;

                float d, h = 0.0;

                for(int i = 0; i < ITER_FRAGMENT; i++) {
                    d = sea_octave((uv+SEA_TIME)*freq,choppy);
                    d += sea_octave((uv-SEA_TIME)*freq,choppy);
                    h += d * amp;
                    uv *= octave_m;
                    freq *= 1.9;
                    amp *= 0.22;
                    choppy = mix(choppy,1.0,0.2);
                }
                return p.y - h;
            }

            vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {
                float fresnel = 1.0 - max(dot(n,-eye),0.0);
                fresnel = pow(fresnel,3.0) * 0.65;

                vec3 reflected = getSkyColor(reflect(eye,n));
                vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12;

                vec3 color = mix(refracted,reflected,fresnel);

                float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);
                color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;

                color += vec3(specular(n,l,eye,60.0));

                return color;
            }

            // tracing
            vec3 getNormal(vec3 p, float eps) {
                vec3 n;
                n.y = map_detailed(p);
                n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;
                n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
                n.y = eps;
                return normalize(n);
            }

            // bteitler: Find out where a ray intersects the current ocean
            float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {

                // Camera position on the y axis.
                float tm = 0.0;
                // Light position on the z axis.
                float tx = -uLightPosition.z;

                // Height, relative to the plane on the Y axis.
                float hx = map(ori + dir * tx);

                // Stop, it's the sky so no more computations. Return the light position.
                if(hx > 0.0) return tx;

                //
                float hm = map(ori + dir * tm);
                float tmid = 0.0;

                for(int i = 0; i < NUM_STEPS; i++) {
                    tmid = mix(tm,tx, hm/(hm-hx));
                    p = ori + dir * tmid;
                    float hmid = map(p);

                    if(hmid < 0.0) {
                        tx = tmid;
                        hx = hmid;
                    } else {
                        tm = tmid;
                        hm = hmid;
                    }
                }
                return tmid;
            }

            // main
            void mainImage( out vec4 fragColor, in vec2 fragCoord ) {

                /*
                * Get the UVs
                * 2D Pixel location passed in as raw pixel, let's divide by resolution
                * to convert to coordinates between 0 and 1
                */
                vec2 uv = fragCoord.xy / iResolution.xy;

                // Shift pixel coordinates from 0 to 1 to between -1 and 1
                uv = uv * 2.0 - 1.0;
                uv.x *= iResolution.x / iResolution.y;

                //fragColor = vec4(uv,0.0,1.0);
                //return;

                // Get the time and scale it.
                float time = iGlobalTime * 0.01;

                // The viewAngle. Needs to be passed through a uniform.
                //vec3 viewAngle = vec3(0.0,0.0,0.0);//vec3(uMVMatrix[0][0],uMVMatrix[0][1],uMVMatrix[0][2]);

                // This is the place where the eye is at.
                //vec3 viewOrigin = vec3(0.0,3.5,5.0); // Original.
                //vec3 viewOrigin = vEyeVec;
                vec3 viewOrigin = uCameraPosition.xyz;


                /*
                * This is the ray direction we are shooting from the camera location ("viewOrigin") that we need to light
                * for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and
                * results in about a 90 degree field of view.
                */
                //vec3 dir = normalize(vec3(uv.xy,-2.0));
                //vec3 dir = normalize(vec3(vLightRay.xy,-2.0));
                vec3 dir = normalize(vLightRay);

                /*
                * Distort the ray a bit for a fish eye effect (if you remove this line, it will remove
                * the fish eye effect and look like a realistic perspective).
                */
                // dir.z += length(uv) * 0.15;

                /*
                * Renormalize the ray direction, and then rotate it based on the previously calculated
                * animation angle "ang".  "fromEuler" just calculates a rotation matrix from a vector of angles.
                */
                // New transformation matrix from modelview as it is the rotation matrix.
                //dir = (uMVMatrix * vec4(normalize(dir),1.0)).xyz;//fromEuler(viewAngle);

                // Ray tracing.
                // Location of intersection with the light.
                vec3 p = vEyeVec;

                //vec3 p;
                //heightMapTracing(viewOrigin,dir,p);

                // Distance vector to ocean surface for this pixel's ray.
                vec3 dist = p - viewOrigin;

                // Calculate the normal on the ocean surface where we intersected (p),
                // using different "resolutions" (in a sense) based on how far away the ray traveled.
                // Normals close to the camera should be calculated with high resolution
                // and normals far from the camera should be calculated with low resolution.
                // The reason to do this is that specular effects (or non linear normal based lighting effects)
                // become fairly random at far distances and low resolutions
                // and can cause unpleasant shimmering during motion.
                vec3 normal = getNormal(p, dot(dist,dist) * EPSILON_NRM);

                // Direction of the far away directional light.
                vec3 light = normalize(uLightPosition);

                // color
                vec3 color = mix(
                    getSkyColor(dir),
                    getSeaColor(p,normal,light,dir,dist),
                    pow(smoothstep(0.0,-0.05,dir.y),0.1)
                );

                // post
                gl_FragColor = vec4(color, 1.0);
            }


            void main( void ){
                vec4 color = vColor;

                //vec2 mapCoord = vec2(vTextureCoord.s, vTextureCoord.t);
                //mainImage( color, mapCoord );
                mainImage( color, gl_FragCoord.xy );

                //gl_FragColor = color;
                //gl_FragColor = texture2D(uColorTexture, vec2(vTextureCoord.s, vTextureCoord.t));
            }


    </script>

    <!--Landscape shaders.-->
    <script id="shader-landscape-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform mat4 uNMatrix;
        uniform vec3 uLightPosition;

        varying vec3 vNormal;
        varying vec3 vLightRay;
        varying vec3 vEyeVec;
        varying vec3 savingVertex;
        varying float seaLvl;

        void main(void)
        {
            seaLvl=10.0;
            savingVertex = aVertexPosition;
            vec3 passVertex = aVertexPosition;

            if( passVertex.y < seaLvl )
                passVertex.y=seaLvl;

            vec4 vertex = uMVMatrix * vec4(passVertex, 1.0);
            vNormal = vec3(uNMatrix * vec4(aVertexNormal, 1.0));
            vec4 light = vec4(uLightPosition,1.0);
            vLightRay = - light.xyz;
            vEyeVec = - vec3(vertex.xyz);
            gl_Position = uPMatrix * vertex;
         }

    </script>

    <script id="shader-landscape-fs" type="x-shader/x-fragment">
        #ifdef GL_ES
            precision highp float;
        #endif

        uniform int uDrawNormal;
        uniform float uShininess;
        uniform float uWave;
        uniform vec3 uLightAmbient;
        uniform vec3 uMaterialDiffuse;
        uniform vec3 uMaterialSpecular;

        varying vec3 vNormal;
        varying vec3 vLightRay;
        varying vec3 vEyeVec;
        varying vec3 savingVertex;
        varying float seaLvl;

        void main(void)
        {
            float h0=seaLvl-5.0;
            float h1=seaLvl-3.0;
            float h2=seaLvl-1.0;
            float h3=seaLvl;
            float h4=seaLvl+6.0;
            float h5=seaLvl+8.0;
            float h6=seaLvl+10.0;
            float h7=seaLvl+12.0;
            float h8=seaLvl+14.0;

            float minH=0.3;

            vec3 color0=vec3(0.131,0.139,0.776);
            vec3 color1=vec3(0.505,0.623,0.905);
            vec3 color2=vec3(0.674,0.788,1.000);
            vec3 color3=vec3(0.074,0.494,0.188);
            vec3 color4=vec3(0.549,0.599,0.315);
            vec3 color5=vec3(0.890,0.792,0.439);
            vec3 color6=vec3(0.627,0.858,0.915);
            vec3 color7=vec3(0.901,0.945,0.941);
            vec3 color8=vec3(1.000,1.000,1.000);

            vec3 finalColor=uMaterialDiffuse;

            vec3 L=normalize(vLightRay);
            vec3 N=normalize(vNormal);

            float lambertTerm=dot(N,-L);

            finalColor=uLightAmbient;

            float h=savingVertex.y;

            vec3 heightColor1;
            vec3 heightColor2;

            float perc;

            if( h < h0 )
            {
                heightColor1=color0;
                heightColor2=color0;
                perc=1.0;
            }
            else if( h < h1 )
            {
                heightColor1=color0;
                heightColor2=color1;
                perc=(h1-h)/(h1-h0);
            }
            else if( h < h2 )
            {
                heightColor1=color1;
                heightColor2=color2;
                perc=(h2-h)/(h2-h1)+ uWave;
                if(perc>1.0) perc-=1.0;
            }
            else if( h < h3 )
            {
                heightColor1=color2;
                heightColor2=color3;
                perc=(h3-h)/(h3-h2);
            }
            else if( h < h4 )
            {
                heightColor1=color3;
                heightColor2=color4;
                perc=(h4-h)/(h4-h3);
            }
            else if( h < h5 )
            {
                heightColor1=color4;
                heightColor2=color5;
                perc=(h5-h)/(h5-h4);
            }
            else if( h < h6 )
            {
                heightColor1=color5;
                heightColor2=color6;
                perc=(h6-h)/(h6-h5);
            }
            else if( h < h7 )
            {
                heightColor1=color6;
                heightColor2=color7;
                perc=(h7-h)/(h7-h6);
            }
            else if( h < h8 )
            {
                heightColor1=color7;
                heightColor2=color8;
                perc=(h8-h)/(h8-h7);
            }
            else
            {
                heightColor1=color8;
                heightColor2=color8;
                perc = 1.0;
            }

            heightColor1 = heightColor1 * perc + heightColor2 * (1.0 - perc);
            vec3 diffuseCol = heightColor1;
            if( (h >= h2) && (lambertTerm > 0.0))
            {
                diffuseCol = heightColor1 * lambertTerm;
            }
            vec3 E = normalize(vEyeVec);
            vec3 R = reflect(L, N);
            float specular = pow( max(dot(R, E), 0.0), uShininess);
            finalColor += diffuseCol + uMaterialSpecular * specular;
            gl_FragColor = vec4(finalColor, 1.0);
        }

    </script>

    <!--Other shaders. -->
    <!--Caustics? To come soon.-->

    <!-- My Utilities. -->
    <script src="js/objects/mesh.js"></script>
    <script src="js/mathTools.js"></script>
    <script src="js/shared.js"></script>
    <script src="js/raytracer.js"></script>
    <script src="js/simulator.js"></script>
    <script src="debug/myUtilites.js"></script>


</head>
<body onload="initWebGL()">
<!--[if lt IE 8]>
<p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade
    your browser</a> to improve your experience.</p>
<![endif]-->

<!-- Add your site or application content here -->

<article id="main-article" class="main-article container">
    <header>
        <nav class="nav-title">
            WebGL Project
        </nav>
        <h1 class="main-title">
            Water Simulation
        </h1>
    </header>

    <div id="content" class="content">
        <div id="menu">
            <button id="enable-scroll">Enable scrolling</button>
            <button id="disable-scroll">Disable scrolling</button>
            <strong id="status" class="enabled">enabled</strong>
        </div>

        <ul>
            <li>+ : augment subdivision</li>
            <li>- : decrement subdivision</li>
            <li>a / d : rotation around Y axis</li>
            <li>w / s : rotation around X axis</li>
        </ul>

        <canvas id="webgl-canvas" width="500" height="500">HTML5 is not supported</canvas>

        <!-- Window and Canvas event handlers. Must be imported after the canvas is defined. -->
        <script src="js/eventHandlers/window_events.js"></script>
        <script src="js/eventHandlers/canvas_events.js"></script>


        <p>
            <input checked="checked" type="checkbox" onclick="changeDrawMode()">Wireframe
        </p>

        <table id="waves" class="">
            <tbody>
            <tr>
                <th id="enable"></th>
                <th id="amplitude">Amplitude</th>
                <th id="wavelength">Wavelength</th>
                <th id="directionX">Direction X</th>
                <th id="directionY">Direction Y</th>
                <th id="speed">Speed</th>
                <th></th>
            </tr>

            <tr id="wave0">
                <td><input checked="checked" type="checkbox"></td>
                <td><input id="amplitude0" value="0.5" size="6" type="text"></td>
                <td><input id="wavelength0" value="20" size="6" type="text"></td>
                <td><input id="directionX0" value="45" size="6" type="text"></td>
                <td><input id="directionY0" value="45" size="6" type="text"></td>
                <td><input id="speed0" value="0.4" size="6" type="text"></td>
                <td>
                    <button class="but0" type="submit" onclick="setWave(0)">Set Data</button>
                </td>
                <!--<th rowspan="4">Big waves</th>-->
            </tr>

            <tr id="wave1">
                <td><input checked="checked" type="checkbox"></td>
                <td><input id="amplitude1" value="0.4" size="6" type="text"></td>
                <td><input id="wavelength1" value="15" size="6" type="text"></td>
                <td><input id="directionX1" value="120" size="6" type="text"></td>
                <td><input id="directionY1" value="45" size="6" type="text"></td>
                <td><input id="speed1" value="0.8" size="6" type="text"></td>
                <td>
                    <button type="submit" onclick="setWave(1)">Set Data</button>
                </td>
            </tr>

            <tr id="wave2">
                <td><input checked="checked" type="checkbox"></td>
                <td><input id="amplitude2" value="0.2" size="6" type="text"></td>
                <td><input id="wavelength2" value="12" size="6" type="text"></td>
                <td><input id="directionX2" value="170" size="6" type="text"></td>
                <td><input id="directionY2" value="45" size="6" type="text"></td>
                <td><input id="speed2" value="0.8" size="6" type="text"></td>
                <td>
                    <button type="submit" onclick="setWave(2)">Set Data</button>
                </td>
            </tr>

            <tr id="wave3">
                <td><input checked="checked" type="checkbox"></td>
                <td><input id="amplitude3" value="0.1" size="6" type="text"></td>
                <td><input id="wavelength3" value="10" size="6" type="text"></td>
                <td><input id="directionX3" value="65" size="6" type="text"></td>
                <td><input id="directionY3" value="45" size="6" type="text"></td>
                <td><input id="speed3" value="1.0" size="6" type="text"></td>
                <td>
                    <button type="submit" onclick="setWave(3)">Set Data</button>
                </td>
            </tr>

            <tr>
                <td colspan="6">
                    <hr>
                </td>
            </tr>

            <tr id="wave4">
                <td><input checked="checked" type="checkbox"></td>
                <td><input value="0.01" size="6" type="text"></td>
                <td><input value="1.0" size="6" type="text"></td>
                <td><input value="170" size="6" type="text"></td>
                <td><input value="45" size="6" type="text"></td>
                <td><input value="1.0" size="6" type="text"></td>
                <th rowspan="4">Small waves</th>
            </tr>

            <tr id="wave5">
                <td><input type="checkbox"></td>
                <td><input value="0.02" size="6" type="text"></td>
                <td><input value="1.5" size="6" type="text"></td>
                <td><input value="110" size="6" type="text"></td>
                <td><input value="45" size="6" type="text"></td>
                <td><input value="0.7" size="6" type="text"></td>
            </tr>

            <tr id="wave6">
                <td><input checked="checked" type="checkbox"></td>
                <td><input value="0.015" size="6" type="text"></td>
                <td><input value="1.2" size="6" type="text"></td>
                <td><input value="80" size="6" type="text"></td>
                <td><input value="45" size="6" type="text"></td>
                <td><input value="0.8" size="6" type="text"></td>
            </tr>

            <tr id="wave7">
                <td><input checked="checked" type="checkbox"></td>
                <td><input value="0.006" size="6" type="text"></td>
                <td><input value="0.8" size="6" type="text"></td>
                <td><input value="60" size="6" type="text"></td>
                <td><input value="45" size="6" type="text"></td>
                <td><input value="1.2" size="6" type="text"></td>
            </tr>
            </tbody>
        </table>
    </div>
</article>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="js/vendor/jquery-1.11.3.min.js"><\/script>')</script>
<script src="js/plugins.js"></script>
<script src="js/main.js"></script>

<!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
<script>
    (function (b, o, i, l, e, r)
    {
        b.GoogleAnalyticsObject = l;
        b[l] || (b[l] =
            function ()
            {
                (b[l].q = b[l].q || []).push(arguments)
            });
        b[l].l = +new Date;
        e      = o.createElement(i);
        r     = o.getElementsByTagName(i)[0];
        e.src = 'https://www.google-analytics.com/analytics.js';
        r.parentNode.insertBefore(e, r)
    }(window, document, 'script', 'ga'));
    ga('create', 'UA-XXXXX-X', 'auto');
    ga('send', 'pageview');
</script>
</body>
</html>
